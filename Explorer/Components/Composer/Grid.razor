@using Compiler
@using Explorer.Utilities.Composer
@using Microsoft.Extensions.Logging
@using static Utilities.Rendering
@using System.ComponentModel.DataAnnotations
@inject IJSRuntime JsRuntime
@inject ILogger<Grid> Logger;
@inject ILogger<GridSnapAssoc> LoggerAssoc;

<div class="grid-container">
    @for (var y = 0; y < GateGrid.Height; y++)
    {
        <div class="grid-outer-row">
            <RowID Name=@(GateGrid.Names[y]) />
            <div class="grid-row">
                <Line X1=0 X2=@(40*GateGrid.Width) />
                @for (var x = 0; x < GateGrid.Width; x++)
                {
                    // Snap point on the cell
                    var cellSnapPoint = new SnapPoint(AddSnapPoint, x, y);
                    @RenderContent(cellSnapPoint)

                    // Snap point between the cells
                    var halfSnapPoint = new SnapPoint(AddSnapPoint, x, y, true);
                    @RenderContent(halfSnapPoint)

                    var localQGate = gates[x,y];
                    var localCellSnapId = cellSnapPoint.Id;

                    <Cell QuantumGate=@(localQGate) Associate="Associate" CellSnapPointId=@(localCellSnapId) />
                }
            </div>
        </div>
    }
</div>

@code {

    [Parameter]
    public GateGrid GateGrid { get; set; } = null!;

    private QuantumGate[,] gates = null!;

    private Dictionary<string, SnapPoint> snapPoints = new Dictionary<string, SnapPoint>();

    private GridSnapAssoc gridSnapAssoc = null!;

    private QuantumGate[,] GetGates()
    {
        Logger.LogInformation("GetGates calling");
        gridSnapAssoc.Clear();
        snapPoints.Clear();
        var arr = new QuantumGate[GateGrid.Width, GateGrid.Height];
        foreach ((var gate, int x, int y) in GateGrid.Gates)
        {
            arr[x, y] = gate;
        }
        return arr;
    }

    protected override void OnInitialized()
    {
        Logger.LogInformation("OnInitialized calling");
        gridSnapAssoc = new GridSnapAssoc(LoggerAssoc, MoveGate);
        gates = GetGates();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Logger.LogInformation("After render method calling");
        await SetReferences();
    }


    private void MoveGate(string oldSnapId, string newSnapId)
    {
        var oldSnap = snapPoints[oldSnapId];
        var newSnap = snapPoints[newSnapId];
        if(oldSnap.X >= gates.GetLength(0) || oldSnap.Y >= gates.GetLength(1))
            throw new ArgumentOutOfRangeException("Old snap does not belong to the gates grid");
        if(newSnap.X >= gates.GetLength(0) || newSnap.Y >= gates.GetLength(1))
            throw new ArgumentOutOfRangeException("New snap does not belong to the gates grid");
        Logger.LogInformation("Moving the gate from {0} to {1}", oldSnap, newSnap);
        GateGrid.MoveGate(oldSnap.X, oldSnap.Y, newSnap.X, newSnap.Y);
        gates = GetGates();
        StateHasChanged();
    }

    private bool Associate(string snapId, string gateId) => gridSnapAssoc.Associate(snapId, gateId);

    private void AddSnapPoint(SnapPoint point)
    {
        snapPoints.Add(point.Id, point);
    }

    /// Expand the grid by adding a new column
    [JSInvokable]
    public void Expand(string snapId)
    {
        var point = snapPoints[snapId];
        Logger.LogInformation("Expanding at {0}", point);
        GateGrid.InsertColumn(point.X);
        gates = GetGates();
        StateHasChanged();
    }

    private async Task SetReferences()
    {
        Logger.LogInformation("Setting the grid references");
        await JsRuntime.InvokeVoidAsync("Library.initGrids");

        // disposable !!!
        var gridRef = DotNetObjectReference.Create(this);
        var assocRef = DotNetObjectReference.Create(gridSnapAssoc);

        await JsRuntime.InvokeVoidAsync(
            "Library.setReferences",
            gridRef, assocRef);
    }
}
